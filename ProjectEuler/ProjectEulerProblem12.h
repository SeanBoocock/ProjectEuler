#pragma once

#include <array>
#include <memory>

#include "ProjectEulerProblem.h"


//The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
//1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
//
//Let us list the factors of the first seven triangle numbers :
//
//1 : 1
//3 : 1, 3
//6 : 1, 2, 3, 6
//10 : 1, 2, 5, 10
//15 : 1, 3, 5, 15
//21 : 1, 3, 7, 21
//28 : 1, 2, 4, 7, 14, 28
//We can see that 28 is the first triangle number to have over five divisors.
//
//What is the value of the first triangle number to have over five hundred divisors ?

class ProjectEulerProblem12 : ProjectEulerProblem<12>
{
	virtual void ExecuteProblem() final
	{
		uint64_t divisorCount = 1;
		uint64_t triangularNumber = 1;
		uint64_t ithNumber = 1;

		static const uint64_t primeArrayCount = 2000000;
		auto primesHolder = std::unique_ptr<uint64_t>(new uint64_t[primeArrayCount]);
		auto primes = primesHolder.get();
		primes[0] = 2;
		primes[1] = 3;

		uint64_t currentCalculatedPrimeCount = 2;
		do
		{
			triangularNumber += ++ithNumber;
			
			typedef std::array<uint64_t, 10000> PrimeFactorArray;
			auto primeFactorCountArray = PrimeFactorArray{};
			PrimeFactorArray::size_type primeFactorIndex = 0;

			// Factor each triangular number into its prime factors
			for (uint64_t triangularNumberFactors = triangularNumber; triangularNumberFactors > 1;)
			{
				for (uint64_t primeIndex = 0; primeIndex < primeArrayCount && triangularNumberFactors > 1; )
				{
					// Haven't calculated this prime yet
					// Lazily calculate primes to use to determine prime factors of triangular numbers
					if (currentCalculatedPrimeCount == primeIndex)
					{
						const uint64_t newestPrimeIndex = primeIndex - 1;
						for (uint64_t newPrime = primes[newestPrimeIndex];; newPrime += 2)
						{
							bool isPrime = true;
							for (uint64_t oldPrimeIndex = 0; oldPrimeIndex <= newestPrimeIndex; ++oldPrimeIndex)
							{
								isPrime = (newPrime % primes[oldPrimeIndex]) != 0;
							}

							if (isPrime)
							{
								primes[primeIndex] = newPrime;
								++currentCalculatedPrimeCount;
								break;
							}
						}
					}

					const uint64_t primeFactor = primes[primeIndex];
					if ((triangularNumberFactors % primeFactor) == 0)
					{
						++primeFactorCountArray[primeFactorIndex];
						triangularNumberFactors /= primeFactor;
					}
					else
					{
						++primeIndex;
						if (primeFactorCountArray[primeFactorIndex] != 0)
						{ 
							++primeFactorIndex;
						}
					}
				}
			}

			// Calculating the divisor count based on the number of prime factors using the divisor (or tau) function
			divisorCount = 1;
			for (auto& entry : primeFactorCountArray)
			{
				divisorCount *= entry + 1;
			}

		} while (divisorCount < 500 
				&& currentCalculatedPrimeCount < primeArrayCount);

		if (divisorCount >= 500)
		{
			std::cout << "The value of the first triangle number to have over five hundred divisors is " << triangularNumber;
		}
		else
		{
			std::cout << "Failed to find the value of the first triangle number to have over five hundred divisors";
		}
	}
} g_problem12;